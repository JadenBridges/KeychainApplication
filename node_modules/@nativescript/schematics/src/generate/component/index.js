"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const schematics_1 = require("@angular-devkit/schematics");
const ast_utils_1 = require("../../ast-utils");
const strings_1 = require("@angular-devkit/core/src/utils/strings");
const parse_name_1 = require("@schematics/angular/utility/parse-name");
const utils_1 = require("../utils");
const core_1 = require("@angular-devkit/core");
const angular_project_parser_1 = require("../../angular-project-parser");
class ComponentInfo {
    constructor() { }
}
let extensions;
function default_1(options) {
    let platformUse;
    let componentInfo;
    return schematics_1.chain([
        (tree) => {
            platformUse = utils_1.getPlatformUse(tree, options);
            // TODO: Remove after @angular/cli@6.1.0 is complete
            if (!options.path) {
                const settings = angular_project_parser_1.getProjectObject(tree, options.project);
                options.path = core_1.normalize(settings.sourceRoot + '/app');
            }
            if (platformUse.nsOnly && options.spec !== true) {
                options.spec = false;
            }
            validateOptions(platformUse, options);
            return tree;
        },
        () => {
            return schematics_1.externalSchematic('@schematics/angular', 'component', utils_1.removeNsSchemaOptions(options));
        },
        (tree) => {
            extensions = utils_1.getExtensions(tree, options);
            componentInfo = parseComponentInfo(tree, options);
        },
        (tree, context) => {
            if (platformUse.nsOnly) {
                // return renameWebTemplate(tree, component.templatePath);
                // don't do anything to the template file, as it its content will be replaced in the next step
                return;
            }
            if (platformUse.useWeb) {
                return renameWebTemplate(tree, componentInfo.templatePath);
            }
            else {
                return removeWebTemplate(tree, context, componentInfo.templatePath);
            }
        },
        (tree) => {
            if (platformUse.nsOnly) {
                ast_utils_1.insertModuleId(tree, componentInfo.classPath);
            }
        },
        (tree, context) => {
            if (platformUse.nsOnly) {
                tree.overwrite(componentInfo.templatePath, `<Button text="${componentInfo.name} works!" class="btn btn-primary"></Button>`);
                return tree;
            }
            if (platformUse.useNs) {
                // return performNsModifications(component)(tree, context);
                return addNativeScriptFiles(componentInfo)(tree, context);
            }
        }
    ]);
}
exports.default = default_1;
;
const validateOptions = (platformUse, options) => () => {
    if (platformUse.webReady && options.inlineTemplate) {
        throw new schematics_1.SchematicsException('You cannot use the --inlineTemplate option for web+ns component!');
    }
    if (!options.nativescript && !options.web) {
        throw new schematics_1.SchematicsException(`You shouldn't disable both --web and --nativescript flags`);
    }
    if (!platformUse.useNs && !platformUse.useWeb) {
        if (options.nativescript) {
            throw new schematics_1.SchematicsException(`Project is not configured for NativeScript, while --web is set to false`);
        }
        if (options.web) {
            throw new schematics_1.SchematicsException(`Project is not configured for Angular Web, while --nativescript is set to false`);
        }
    }
};
const parseComponentInfo = (tree, options) => {
    // const path = `/${projectSettings.root}/${projectSettings.sourceRoot}/app`;
    const component = new ComponentInfo();
    const parsedPath = parse_name_1.parseName(options.path || '', options.name);
    component.name = strings_1.dasherize(parsedPath.name);
    const className = `/${component.name}.component.ts`;
    const templateName = `/${component.name}.component.html`;
    tree.actions.forEach(action => {
        if (action.path.endsWith(templateName)) {
            component.templatePath = action.path;
        }
        if (action.path.endsWith(className)) {
            component.classPath = action.path;
        }
    });
    if (!component.classPath || !component.templatePath) {
        throw new schematics_1.SchematicsException(`Failed to find generated component files from @schematics/angular. Please contact the @nativescript/schematics author.`);
    }
    return component;
};
const renameWebTemplate = (tree, templatePath) => {
    if (extensions.web) {
        const webName = templatePath.replace('.html', `${extensions.web}.html`);
        tree.rename(templatePath, webName);
    }
    return tree;
};
const removeWebTemplate = (tree, context, templatePath) => 
// tree.delete(templatePath);
schematics_1.filter((path) => !path.match(templatePath))(tree, context);
// const performNsModifications = (component: ComponentInfo) =>
//   (tree: Tree, context: SchematicContext) => {
//     insertModuleId(component.classPath)(tree);
//     return addNativeScriptFiles(component)(tree, context);
//   }
const addNativeScriptFiles = (component) => {
    const parsedTemplate = parse_name_1.parseName('', component.templatePath);
    parsedTemplate.name = parsedTemplate.name.replace('.html', `${extensions.ns}.html`);
    const templateSource = schematics_1.apply(schematics_1.url('./_files'), [
        schematics_1.template({
            path: parsedTemplate.path,
            fileName: parsedTemplate.name,
            name: component.name
        }),
    ]);
    return schematics_1.mergeWith(templateSource);
};
//# sourceMappingURL=index.js.map